{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#prologue","title":"Prologue","text":"<p>What's past is prologue.</p>"},{"location":"#purpose","title":"Purpose","text":"<p><code>Prologue</code> is a powerful and flexible web framework written in Nim. It is ideal for building elegant and high performance web services.</p> <p>Reduce magic. Reduce surprise.</p>"},{"location":"#documentation","title":"Documentation","text":"Documentation Index Page Core API Index Page Search Page Full API Index Page Search Page"},{"location":"#installation","title":"Installation","text":"<p>First you should install Nim language which is an elegant and high performance language. Follow the instructions and set environment variables correctly.</p> <p>Then you can use <code>nimble</code> command to install prologue.</p> <pre><code>nimble install prologue\n</code></pre> <p><code>Prologue</code> also provides some extensions. You can use <code>logue extension</code> to install all of them. If you just want to install one of them, you can use <code>logue extension module</code> for example <code>logue extension redis</code>.</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#hello-world","title":"Hello World","text":"<pre><code># app.nim\nimport prologue\n\nproc hello*(ctx: Context) {.async.} =\n  resp \"&lt;h1&gt;Hello, Prologue!&lt;/h1&gt;\"\n\nlet app = newApp()\napp.addRoute(\"/\", hello)\napp.run()\n</code></pre> <p>Run app.nim ( <code>nim c -r app.nim</code> ). Now the server is running at <code>localhost:8080</code>.</p>"},{"location":"#another-example","title":"Another example","text":"<pre><code># app.nim\nimport prologue\nimport prologue/middlewares\n\n\n# Async Function\nproc home*(ctx: Context) {.async.} =\n  resp \"&lt;h1&gt;Home&lt;/h1&gt;\"\n\nproc helloName*(ctx: Context) {.async.} =\n  resp \"&lt;h1&gt;Hello, \" &amp; ctx.getPathParams(\"name\", \"Prologue\") &amp; \"&lt;/h1&gt;\"\n\nproc doRedirect*(ctx: Context) {.async.} =\n  resp redirect(\"/hello\")\n\nproc login*(ctx: Context) {.async.} =\n  resp loginPage()\n\nproc do_login*(ctx: Context) {.async.} =\n  resp redirect(\"/hello/Nim\")\n\n\nlet settings = newSettings(appName = \"Prologue\")\nvar app = newApp(settings = settings)\napp.use(debugRequestMiddleware())\napp.addRoute(\"/\", home, @[HttpGet, HttpPost])\napp.addRoute(\"/home\", home, HttpGet)\napp.addRoute(\"/redirect\", doRedirect, HttpGet)\napp.addRoute(\"/login\", login, HttpGet)\napp.addRoute(\"/login\", do_login, HttpPost, middlewares = @[debugRequestMiddleware()])\napp.addRoute(\"/hello/{name}\", helloName, HttpGet)\napp.run()\n</code></pre> <p>Run app.nim (<code>nim c -r app.nim</code>). Now the server is running at <code>localhost:8080</code>.</p>"},{"location":"#more-examples","title":"More examples","text":"<ul> <li>HelloWorld</li> <li>ToDoList</li> <li>ToDoApp</li> <li>Blog</li> <li>Additional examples repository</li> </ul>"},{"location":"#extensions","title":"Extensions","text":"<p>If you need more extensions, you can refer to awesome prologue and awesome nim.</p>"},{"location":"#donations","title":"Donations","text":"<p>Thanks for supporting me.</p> <p>https://github.com/sponsors/planety</p>"},{"location":"#stars","title":"Stars","text":""},{"location":"cli/","title":"Command line tool","text":"<p><code>Prologue</code> ships with <code>logue</code> tool to help you start a new project quickly.</p>"},{"location":"cli/#creates-a-new-project","title":"Creates a new project","text":"<p>Type <code>logue init projectName</code> in command line to create a new project. This will create <code>.env</code> file for configuration. If you want to use JSON format config file, please add <code>--useConfig</code> or <code>-u</code> to the command.</p> <pre><code>logue init newapp\n</code></pre> <p>Using json config:</p> <pre><code>logue init newapp --useConfig\n# or\nlogue init newapp -u\n</code></pre>"},{"location":"cli/#install-the-extensions","title":"Install the extensions","text":"<p>Type <code>logue extension extensionName</code> to install the specific extension which is specified in <code>prologue.nimble</code>. If you want to install all the extensions, please input <code>logue extension all</code>.</p> <pre><code>logue extension redis\n</code></pre> <p>Install all the extensions:</p> <pre><code>logue extension all\n</code></pre>"},{"location":"configure/","title":"Configuration","text":"<p>When starting a project, you need to configure your application.</p>"},{"location":"configure/#simple-settings","title":"Simple settings","text":"<p>For small program, you could use the default <code>settings</code> which is provided by <code>Prologue</code>.</p> <pre><code>import prologue\n\nvar app = newApp()\napp.run()\n</code></pre> <p>You may want to specify settings by yourself. <code>Prologue</code> provides <code>newSettings</code> function to create a new settings. The program below creates a new settings with <code>debug = false</code>. This will disable the default logging.</p> <pre><code>import prologue\n\nlet settings = newSettings(debug = false)\nvar app = newApp(settings = settings)\napp.run()\n</code></pre> <p>You can also read settings from <code>.env</code> file. <code>Prologue</code> provides <code>loadPrologueEnv</code> to read data from <code>.env</code> file. You can use <code>get</code> or <code>getOrDefault</code> to retrieve the value.</p> <pre><code>import prologue\n\nlet\n  env = loadPrologueEnv(\".env\")\n  settings = newSettings(appName = env.getOrDefault(\"appName\", \"Prologue\"),\n                         debug = false,\n                         port = Port(env.getOrDefault(\"port\", 8080))\n    )\n\nvar app = newApp(settings = settings)\napp.run()\n</code></pre>"},{"location":"configure/#config-file","title":"Config file","text":"<p>You need to specify a config file for a big project. <code>Prologue</code> provides <code>loadSettings</code> to read JSON file. You should give the path of the Json config file.</p> <pre><code>let settings = loadSettings(\".config/config.debug.json\")\nvar app = newApp(settings)\n</code></pre> <p><code>.config/config.debug.json</code></p> <p>In config file, the <code>prologue</code> key must be present. The corresponding data will be used by framework. Among the corresponding data, the <code>secretKey</code> must be present and should not be empty. Otherwise, the program will raise exception. Other keys can be absent, they will be given a default value setting by <code>Prologue</code>.</p> <p>Below is the type of settings:</p> <pre><code>address: string\nport: int\ndebug: bool\nreusePort: bool\nappName: string\nsecretKey: string\nbufSize: int\n</code></pre> <pre><code>{\n  \"prologue\": {\n    \"address\": \"\",\n    \"port\": 8080,\n    \"debug\": true,\n    \"reusePort\": true,\n    \"appName\": \"\",\n    \"secretKey\": \"Set by yourself\",\n    \"bufSize\": 40960\n  },\n  \"name\": \"debug\"\n}\n</code></pre>"},{"location":"configure/#changing-config-file-via-environment-variable","title":"Changing config file via environment variable","text":"<p><code>Prologue</code> also supports automatically loading configure file by environment variables. The <code>.config</code> directory must be present in the current path(in the same directory as the main program). If you don't set the environment variable(namely <code>PROLOGUE</code>) or the value is <code>default</code>, the application will read <code>.config/config.json</code> file. Otherwise, if you set the <code>PROLOGUE</code> environment variable to <code>custom</code>, the application will read <code>.config/config.custom.json</code>. The common names includes <code>debug</code> and <code>production</code>. If the file doesn't exist, it will raise exception.</p> <pre><code>import prologue\n\nvar app = newAppQueryEnv()\napp.run()\n</code></pre>"},{"location":"context/","title":"Context","text":"<p>Context is initialized when a new request enters. You can get the information of the whole Context when you are writing handlers.</p> <p>You can use attributes of context such as <code>request</code>, <code>response</code>, <code>session</code> and so on.</p> <p>For example, you can get the HTTP method of the request.</p> <pre><code>proc login*(ctx: Context) {.async.} =\n  doAssert ctx.request.reqMethod == HttpPost\n</code></pre>"},{"location":"context/#context-utils","title":"Context utils","text":""},{"location":"context/#getpostparamsoption","title":"getPostParamsOption","text":"<p>Gets the parameters by HttpPost as an <code>Option[string]</code>.</p> <p>Note that: <code>getPostParamsOption</code> only handles <code>form-urlencoded</code> types.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  resp ctx.getPostParamsOption(\"username\").get()\n</code></pre> <p>If you want to specify a default value to return, take a look at getPostParams</p>"},{"location":"context/#getqueryparamsoption","title":"getQueryParamsOption","text":"<p>Gets the query strings(for example, \"www.google.com/hello?name=12\", <code>name=12</code>) as an <code>Option[string]</code>.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  doAssert ctx.getQueryParamsOption(\"name\").get() == \"12\"\n</code></pre> <p>If you want to specify a default value to return, take a look at getQueryParams</p>"},{"location":"context/#getpathparamsoption","title":"getPathParamsOption","text":"<p>Gets the route parameters(for example, \"/hello/{name}\") as an <code>Option[string]</code>.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  resp \"&lt;h1&gt;Hello, \" &amp; ctx.getPathParamsOption(\"name\").get() &amp; \"&lt;/h1&gt;\"\n</code></pre> <p>If you want to specify a default value to return and have automatic parsing to int, float or bool (depending on the type of the default you provide), take a look at getPathParams</p>"},{"location":"context/#getformparamsoption","title":"getFormParamsOption","text":"<p>Gets the contents of the form if key exists. Otherwise <code>default</code> will be returned. If you need the filename of the form, use <code>getUploadFile</code> instead.</p> <p>Note that: <code>getFormParams</code> handles both <code>form-urlencoded</code> and <code>multipart/form-data</code>.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  resp \"&lt;h1&gt;Hello, \" &amp; ctx.getFormParamsOption(\"name\").get() &amp; \"&lt;/h1&gt;\"\n</code></pre> <p>If you want to specify a default value to return, take a look at getFormParams</p>"},{"location":"context/#setresponse","title":"setResponse","text":"<p>It is handy to make the response of <code>ctx</code>.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  ctx.setResponse(Http200, \"setResponse\")\n</code></pre>"},{"location":"context/#attachment","title":"attachment","text":"<p><code>attachment</code> is used to specify the file will be downloaded.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  let downloadName = \"test.txt\"\n  ctx.attachment(downloadName)\n</code></pre>"},{"location":"context/#staticfileresponse","title":"staticFileResponse","text":"<p>Returns static files response. The following middlewares processing will be discarded.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  await ctx.staticFileResponse(\"index.html\", \"static\")\n</code></pre>"},{"location":"context/#getuploadfile","title":"getUploadFile","text":"<p>Gets the <code>UploadFile</code> from request. <code>UploadFile</code> can be saved to disk using <code>save</code> function.</p> <pre><code>proc upload(ctx: Context) {.async.} =\n  if ctx.request.reqMethod == HttpGet:\n    await ctx.staticFileResponse(\"tests/local/uploadFile/upload.html\", \"\")\n  elif ctx.request.reqMethod == HttpPost:\n    let file = ctx.getUploadFile(\"file\")\n    file.save(\"tests/assets/temp\")\n    resp fmt\"&lt;html&gt;&lt;h1&gt;{file.filename}&lt;/h1&gt;&lt;p&gt;{file.body}&lt;/p&gt;&lt;/html&gt;\"\n</code></pre>"},{"location":"deployment/","title":"Deploying Prologue with nginx and docker","text":"<p>This is an example of how you can deploy a prologue web-application that was compiled under Linux. .</p>"},{"location":"deployment/#base-images","title":"Base Images","text":"<p>We will look at 2 base images as starting points:</p> <ol> <li>bitnami/mindeb</li> <li>alpine</li> </ol> <p>The process is similar for both, but does contain differences, particularly in the dockerfile and commands needed to compile your project.</p> <p>This guide assumes that:</p> <ol> <li>You have a server</li> <li>You can ssh into your server</li> <li>You can copy files to your server via e.g. scp</li> <li>You have set up your server with a domain name</li> </ol>"},{"location":"deployment/#compile-your-binary","title":"Compile your binary","text":"<p>Compiling your binary differs between alpine and other linux images. This is because unlike most other linux distributions, alpine does not use the <code>gnu c library</code> (glibc) to link its binaries against. Alpine uses <code>musl</code>, which is much more minimalistic.</p> <p>Because <code>musl</code> and <code>glibc</code> are different, compiling your application to link with them also differs.</p>"},{"location":"deployment/#on-bitnamimindeb","title":"On bitnami/mindeb","text":"<p>bitnami/minideb is basically a debian image, reduced to the minimum.</p> <p>Since it is based on debian, it uses <code>gnu c library</code> (glibc), which is the main advantage of this image. </p> <p>Since the majority of Linux systems use <code>glibc</code>, compiling on any Linux distro will give you a binary that is dynamically linked against your <code>glibc</code> version and thus is likely to work in the image. If you have to ask whether your distro is using <code>glibc</code>, you are using <code>glibc</code>.</p> <p>You can compile your project like this: <pre><code>nim c \\\n--forceBuild:on \\\n--opt:speed \\\n--define:release \\\n--threads:on \\\n--mm:orc \\\n--deepcopy:on \\\n--define:lto \\\n--define:ssl \\\n--hints:off \\\n--outdir:\".\" \\\n&lt;PATH_TO_YOUR_MAIN_PROJECT_FILE&gt;.nim\n</code></pre> For Clang users (e.g. MacOs): Clang doesn't work properly with <code>--define:lto</code>. Replace it with <code>--passC:\"-flto\" --passL:\"-flto\"</code> which achieves the same thing.</p> <p>If you want to avoid re-typing all the flags, you can define them in a nimble task that you can trigger instead! Just add the following to your <code>&lt;YOUR_PROJECT&gt;.nimble</code> file (run <code>nimble init</code> if you don't have one):</p> <pre><code>task release, \"Build a production release\":\n  --verbose\n  --forceBuild:on\n  --opt:speed\n  --define:release\n  --threads:on\n  --mm:orc\n  --deepcopy:on\n  --define:lto\n  --define:ssl # If you use smtp clients\n  --hints:off\n  --outdir:\".\"\n  setCommand \"c\", \"src/&lt;YOUR_MAIN_FILE&gt;.nim\"\n</code></pre> <p>This allows you to run <code>nimble release</code> in your project to compile it with the specified flags!</p>"},{"location":"deployment/#on-alpine","title":"On alpine","text":"<p>Alpine is among the smallest image out there.  At barely 5.53MB, any image you base on it is unlikely to get large.  This doesn't have effects on your application's performance, but does speed deployment as the image uploads faster to your server.</p> <p>Since Alpine uses <code>musl</code>, compiling has some extra steps. For simplicities' sake, we will be linking to musl dynamically.</p>"},{"location":"deployment/#install-musl","title":"Install musl","text":"<ol> <li>download the tar file</li> <li>Unpack the tar file somewhere</li> <li>Run <code>bash configure</code> in the unpacked directory. WARNING: Make sure that you do NOT install musl with <code>--prefix</code> being  <code>/usr/local</code>, as that may adversely affect your system. Use somewhere else where it is unlikely to override files, e.g. <code>/usr/local/musl</code>. This path will further be referred to as <code>&lt;MUSL_INSTALL_PATH&gt;</code></li> <li>Run <code>make &amp;&amp; make install</code> in the unpacked directory</li> <li>Add <code>&lt;MUSL_INSTALL_PATH&gt;</code> to your PATH environment variable</li> <li>Validate whether you set everything up correctly by opening a new terminal and seeing whether you have access to the <code>musl-gcc</code> binary</li> </ol>"},{"location":"deployment/#compiling-your-dynamically-linked-musl-binary","title":"Compiling your dynamically linked musl binary","text":"<p>Like before, you can write a compile command.  This time though, we need to tell the compiler to use <code>musl-gcc</code> instead of <code>gcc</code> to dynamically link with <code>musl</code>. We similarly want to replace the linker with <code>musl-gcc</code>. We can use the flags <code>--gcc.exe:\"musl-gcc\"</code> and <code>--gcc.linkerexe:\"musl-gcc\"</code> to get a compile command:</p> <pre><code>nim c \\\n--gcc.exe:\"musl-gcc\" \\\n--gcc.linkerexe:\"musl-gcc\" \\\n--forceBuild:on \\\n--opt:speed \\\n--define:release \\\n--threads:on \\\n--mm:orc \\\n--deepcopy:on \\\n--define:lto \\\n--define:ssl \\\n--hints:off \\\n--outdir:\".\" \\\n&lt;PATH_TO_YOUR_MAIN_PROJECT_FILE&gt;.nim\n</code></pre> <p>Instead of a bash script we can also just set up a nimble task instead: <pre><code>task alpine, \"Build an alpine release\":\n  --verbose\n  --gcc.exe:\"musl-gcc\"\n  --gcc.linkerexe:\"musl-gcc\"\n  --forceBuild:on\n  --opt:speed\n  --define:release\n  --threads:on\n  --mm:orc\n  --deepcopy:on\n  --define:lto\n  --define:ssl\n  --hints:off\n  --outdir:\".\"\n  setCommand \"c\", \"src/nimstoryfont.nim\"\n</code></pre></p>"},{"location":"deployment/#prepare-buildfiles","title":"Prepare buildFiles","text":"<ol> <li>Set up the server to have SSL certificates with certbot to get <code>fullchain.pem</code> and <code>privkey.pem</code> files</li> <li>Write an <code>nginx.conf</code> file to configure nginx</li> <li>Write a bash file <code>dockerStartupScript.sh</code> to run inside the docker container when starting it.</li> <li>Write a <code>settings.json</code> file for prologue</li> </ol> <p>We will store these files in a directory called <code>buildFiles</code> and include them in our docker image(s) later.</p>"},{"location":"deployment/#set-up-your-server-to-have-ssl-certificates-with-certbot","title":"Set up your server to have SSL certificates with certbot","text":"<p>There are many great resources on how you can get free SSL certificates. We recommend using certbot.  Follow the instructions on their website to set up your certificates.</p> <p>After the initial setup, you should automate the renewal of those certificates. Renewal is easily done with <code>sudo certbot renew</code>, but requires you to shut down the webserver first and boot it up after renewal again. We recommend setting up a cronjob to regularly run the <code>certbot renew</code> command. User certbot's \"pre-hook\" and \"post-hook\" to shut down/starts up your container/docker-compose before and after the actual renewal happens.</p> <pre><code>certbot renew --pre-hook \"docker container stop &lt;YOUR_CONTAINER_NAME&gt;\" --post-hook \"docker container start &lt;YOUR_CONTAINER_NAME&gt;\"\n</code></pre>"},{"location":"deployment/#provide-an-nginxconf-config-file","title":"Provide an <code>nginx.conf</code> config file","text":"<p>Nginx requires a config file, <code>nginx.conf</code> to define what files to serve and how to forward requests to the prologue application.</p> <p>Here we'll set nginx up to use SSL with the SSL certificates received from the previous step. Further, to make nginx forward requests to our prologue backend, we use its \"proxy_pass\" directive.</p> <p>Note that all directories in the config file are directories within the docker container, not your actual server.</p> <p>See below an example of a small <code>nginx.conf</code> file: <pre><code>#user http;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    types_hash_max_size 4096;\n\n    sendfile        on;\n\n    keepalive_timeout  30;\n    proxy_send_timeout 30;\n\n    # Enforces HTTPS by redirecting users with HTTP requests to the HTTPS URL\n    server {\n        listen 80;\n        listen [::]:80;\n\n        server_name &lt;SERVER_NAME&gt;;\n\n        return 301 https://$server_name$request_uri;\n    }\n\n    server {\n        server_name &lt;SERVER_NAME&gt;;\n        autoindex off;\n\n        listen 443 ssl http2;\n        listen [::]:443 ssl http2;       \n\n        root /media;\n\n        # Passes requests on to the prologue application server\n        location /server {\n            rewrite ^/server/(.*) /$1  break; #Removes \"/server\" from the url for the application-server\n\n            proxy_pass http://localhost:8080; #Hands request over to localhost:8080 where the application server is listening\n            proxy_set_header Host $host;\n            proxy_send_timeout 600;\n            proxy_set_header X-Real_IP $remote_addr;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   /usr/share/nginx/html;\n        }\n\n        ssl_certificate /cert/live/&lt;SERVER_NAME&gt;/fullchain.pem;\n        ssl_certificate_key /cert/live/&lt;SERVER_NAME&gt;/privkey.pem;\n    }\n}\n</code></pre></p> <p>Note that the file assumes there will be a <code>fullchain.pem</code> and <code>privkey.pem</code>, which you currently have on your server (e.g. <code>/etc/letsencrypt/live</code>).  We will make these certificates accessible by creating the <code>/cert/live</code> directories inside the docker image and mounting the certificate directory to that folder (e.g. when creating a container via docker volumes).</p> <p>For now store your <code>nginx.conf</code> file in your <code>./buildFiles</code> directory.</p>"},{"location":"deployment/#provide-a-settingsjson-config-file-for-prologue","title":"Provide a <code>settings.json</code> config file for prologue","text":"<p>In order for prologue to function correctly, we will provide a simple settings file.</p> <pre><code>    \"prologue\": {\n        \"address\": \"\",\n        \"port\": 8080,\n        \"debug\": false,\n        \"reusePort\": true,\n        \"appName\": \"&lt;YOUR APP NAME&gt;\",\n        \"secretKey\": \"&lt;YOUR SECRET KEY&gt;\",\n        \"bufSize\": 409600\n    },\n    \"name\": \"production\",\n</code></pre> <p>Note that the port you specify here must be the same port used in the <code>proxy_pass</code> directive of <code>./buildFiles/nginx.conf</code>.</p> <p>Put this <code>settings.json</code> in your <code>./buildFiles</code> directory. </p>"},{"location":"deployment/#setting-up-docker","title":"Setting up docker","text":"<p>After completing the prior steps, we can now think how to deploy our application how we want to deploy our application and server. We have 2 different applications to manage here: nginx and our prologue application. We can deploy these in 2 different ways:</p> <ul> <li>Prologue and Nginx in the same container (simpler)</li> <li>Prologue and Nginx in separate containers via docker-compose (Enables hosting multiple web-applications from the same server)</li> </ul>"},{"location":"deployment/#a-prologue-and-nginx-in-the-same-container","title":"A) Prologue and Nginx in the same container","text":"<p>When deploying prologue and nginx in the same container we need to start both applications on when starting the container. To do so we can set up a <code>startupScript.sh</code> file that gets executed when the container gets started. We will be using <code>openrc</code> to start and manage nginx.</p> <pre><code>#!/bin/sh\n# This file contains all commands that shall be run on the docker container on startup\nopenrc boot # Enables running rc-service, which manages nginx\nrc-service nginx start # Starts up nginx\n/&lt;YOUR_BINARY&gt; # Starts your prologue application\n</code></pre> <p>Store your script file locally in <code>./buildFiles/startupScript.sh</code>.</p>"},{"location":"deployment/#write-your-dockerfile","title":"Write your dockerfile","text":"<p>After completing the prior steps, we can write a <code>dockerfile</code>. It will contain the instructions to create a docker image, from which containers are made.</p> <p>This process differs between <code>bitnami/minideb</code> and <code>alpine</code>, since <code>alpine</code> uses <code>apk</code> to install packages from the alpine repositories while <code>bitnami/minideb</code> uses apt to install debian packages.  This means the installation commands and package names differ.</p> <p>We will also set up various folders, in order to later use them as mounting points for docker volumes when creating containers from our images.  This way you can access files inside the container (e.g. media files so that nginx can serve them, or an sqlite database) without loosing them when the container shuts down.</p> <p>Store the dockerfile on your applications root directory.</p>"},{"location":"deployment/#on-bitnamiminideb","title":"On <code>bitnami/minideb</code>","text":"<p>To install packages without <code>apt</code>'s commandline prompts, this image ships a <code>install_packages</code> command. Here an example <code>dockerfile</code>: <pre><code>FROM bitnami/minideb\n\n# Install dependencies\nRUN apt update\nRUN install_packages openrc openssl nginx\n# RUN install_packages sqlite3 # in case you use an sqlite3 database\n\n# Copy necessary files, the first paths are all relative to your current working directory\nCOPY ./&lt;PATH_TO_YOUR_BINARY&gt; .\nCOPY ./buildFiles/nginx.conf /etc/nginx/nginx.conf\nCOPY ./buildFiles/dockerStartScript.sh .\nCOPY ./buildFiles/settings.json /settings.json\nRUN chmod 777 /settings.json\n\n# Setup directories to add volumes to when creating the container\nRUN mkdir -p /run/nginx\nRUN mkdir -p /cert/live/&lt;YOUR_SERVER_NAME&gt;\nRUN mkdir -p /cert/archive/&lt;YOUR_SERVER_NAME&gt;\nRUN mkdir /media\n\n#Startup command\nRUN chmod +x /dockerStartScript.sh\nCMD [\"/dockerStartScript.sh\"]\n</code></pre></p>"},{"location":"deployment/#on-alpine_1","title":"On <code>alpine</code>","text":"<p>Here an example dockerfile: <pre><code>FROM alpine\n\n# Install dependencies\nRUN apk update\nRUN apk add openrc nginx openssl bash\n# RUN apk add sqlite-libs # in case you use an sqlite3 database\n\n# Copy necessary files\nCOPY ./buildFiles/nginx.conf /etc/nginx/nginx.conf\nCOPY ./buildFiles/dockerStartScript.sh .\nCOPY ./buildFiles/settings.json /settings.json\nRUN chmod 777 /settings.json\n\n# Setup directories to add volumes to when creating the container\nRUN mkdir -p /run/nginx\nRUN mkdir -p /cert/live/&lt;YOUR_SERVER_NAME&gt;\nRUN mkdir -p /cert/archive/&lt;YOUR_SERVER_NAME&gt;\nRUN mkdir /media\n\n#Startup command\nRUN chmod +x /dockerStartScript.sh\nCMD [\"/dockerStartScript.sh\"]\n</code></pre></p>"},{"location":"deployment/#build-the-docker-image","title":"Build the docker image","text":"<p>With the binary, buildFiles and dockerfile ready, you can create your image:</p> <pre><code># Creates your image\nsudo docker build -t &lt;YOUR_IMAGE_NAME&gt; .\n# Stores your image in your current working directory in a file called \"image.tar\"\nsudo docker save -o image.tar &lt;YOUR_IMAGE_NAME&gt;\n</code></pre> <p>Once created, move that image file to your server, e.g. through <code>scp</code>.</p>"},{"location":"deployment/#run-the-docker-image-on-your-server","title":"Run the docker image on your server","text":"<p>After copying your <code>image.tar</code> file to the server, you can load it there with docker and run a container from it. Besides starting the container, the commands needs to:</p> <ol> <li>Open up the container's HTTP port to the internet (80)</li> <li>Open up the container's HTTPS port to the internet (443)</li> <li>Mount the volumes for certificates, media files etc.</li> <li>(Optional) Open up a port to talk to your database (e.g. 5432 for Postgres)</li> </ol> <p>Opening up the ports is done using <code>-p</code>, mounting the volumes with <code>-v</code>. Note that in <code>-v</code>, the first path is the one outside your container.  It specifies which folder on your server to mount.  The second path is the one inside your container.  It specifies which folder in your container the server folder gets mounted to.</p> <p>You may want to write yourself a script that loads the file, stops and removes any previously running container and then creates a new one from the new image.  Here an example: <pre><code>#!/bin/sh\nsudo docker load -i image.tar\n\nsudo docker container stop &lt;YOUR_CONTAINER_NAME&gt;\nsudo docker container rm &lt;YOUR_CONTAINER_NAME&gt;\n\nsudo docker run -p 80:80 -p 443:443 \\\n-v /etc/letsencrypt/live/&lt;SERVER_NAME&gt;:/cert/live/&lt;SERVER_NAME&gt;:ro \\\n-v /etc/letsencrypt/archive/&lt;SERVER_NAME&gt;:/cert/archive/&lt;SERVER_NAME&gt;:ro \\\n-v &lt;PATH_TO_MEDIA_FOLDER&gt;/media:/media \\\n-v &lt;PATH_TO_DIRECTORY_FOR_SERVER_LOGS&gt;:/var/log/nginx \\\n--name &lt;YOUR_IMAGE_NAME&gt; &lt;YOUR_CONTAINER_NAME&gt;\n</code></pre></p> <p>Now you can run the command (or script), and your container will start up and be accessible via HTTP and HTTPS!</p>"},{"location":"deployment/#b-prologue-and-nginx-in-separate-containers-via-docker-compose","title":"B) Prologue and Nginx in separate containers via docker-compose","text":"<p>You can have your proxy (nginx) and your webserver (prologue) also in different images and thus different containers, that can communicate. For this you need to set it up so they get started together, with the ports they need opened and volumes they need mounted etc.  That's where you use docker-compose.</p> <p>First, add 2 directories to <code>./buildFiles</code> to separate the config files and dockerfiles of your proxy and your webserver:</p> <ul> <li><code>./buildFiles/nginx</code></li> <li>Move the <code>nginx.conf</code> here</li> <li><code>./buildFiles/prologue</code></li> <li>Move the <code>settings.json</code> here</li> <li>Move your application binary here</li> </ul> <p>Also, change your commands or nimble tasks for compiling to output into the <code>./buildFiles/prologue</code> directory.</p>"},{"location":"deployment/#write-your-docker-composeyml","title":"Write your <code>docker-compose.yml</code>","text":"<p>A docker compose file contains the same things you would write in a <code>docker run</code> command: name of the container, the image to use, which volumes to mount, which ports to expose etc.</p> <p>Here an example of such a <code>docker-compose.yml</code> file that you can keep in your projects main folder: <pre><code>version: \"3.4\"\nservices:\n  #Nginx Reverse Proxy\n  proxy:\n    image: &lt;NGINX_IMAGE_NAME&gt;\n    ports:\n     - \"443:443\"\n     - \"80:80\"\n    volumes:\n      -/etc/letsencrypt/live/&lt;SERVER_NAME&gt;:/cert/live/&lt;SERVER_NAME&gt;\n      -/etc/letsencrypt/archive/&lt;SERVER_NAME&gt;:/cert/archive/&lt;SERVER_NAME&gt;\n      - &lt;PATH_TO_MEDIA_FOLDER&gt;/media:/media\n      - &lt;PATH_TO_DIRECTORY_FOR_SERVER_LOGS&gt;:/var/log/nginx\n    container_name: &lt;NGINX_CONTAINER_NAME&gt;\n\n  #Prologue webserver that receives requests on port 8080\n  prologue:\n    image: &lt;PROLOGUE_IMAGE_NAME&gt;\n    expose: \n      - \"8080\" # Annotation for readability to make it clear that this container should be talked to on port 8080\n    volumes:\n      - &lt;PATH_TO_MEDIA_FOLDER&gt;/media:/media\n    container_name: &lt;PROLOGUE_CONTAINER_NAME&gt;\n</code></pre></p> <p>To run this docker compose file with <code>docker-compose up</code>, you will first need to build images with the names you specify up there.</p> <p>This means you now need 2 dockerfiles that can build these images. </p>"},{"location":"deployment/#write-your-nginx-dockerfile","title":"Write your nginx dockerfile","text":"<p>An example for a dockerfile of an alpine image with nginx: <pre><code>FROM alpine\n\n# Install dependencies\nRUN apk update\nRUN apk add nginx openssl --no-cache\n\n# Copy necessary files\nCOPY ./nginx.conf /etc/nginx/nginx.conf #Filepath is relative to dockerfile\n\n# Setup directories to add volumes to when creating the container\nRUN mkdir -p /run/nginx\nRUN mkdir -p /cert/live/&lt;YOUR_SERVER_NAME&gt;\nRUN mkdir -p /cert/archive/&lt;YOUR_SERVER_NAME&gt;\nRUN mkdir /media\n\n# Command to start nginx in container\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n</code></pre></p> <p>Since the container only contains nginx, we can use <code>CMD [\"nginx\", \"-g\", \"daemon off;\"]</code> instead of a bash script to start it. </p> <p>Put the dockerfile in <code>./buildFiles/nginx</code></p> <p>We could have used the official nginx alpine image instead of vanilla alpine, but decided against it. Main reason being that the image appears to be binary-incompatible with the nginx-mods that can be installed via <code>apk</code>. Other than that, the official nginx image can be used just as well.</p>"},{"location":"deployment/#write-your-prologue-dockerfile","title":"Write your prologue dockerfile","text":"<p>An example for a dockerfile of an alpine image with our prologue application: <pre><code>FROM alpine\n\n# Install dependencies\nRUN apk update\nRUN apk add openssl\n# RUN apk add sqlite-libs # in case you use an sqlite3 database\n\n# Copy necessary files\nCOPY ./&lt;YOUR_APPLICATION_BINARY&gt; .    #Filepath is relative to dockerfile\nCOPY ./settings.json /settings.json   #Filepath is relative to dockerfile\n\n# Setup necessary directories\nRUN mkdir /media\n\n#Startup command\nCMD [\"/&lt;YOUR_APPLICATION_BINARY&gt;\"]\n</code></pre> Since the container only contains our application, we can just start it via <code>CMD [\"/&lt;YOUR_APPLICATION_BINARY&gt;\"]</code>.</p> <p>Put the dockerfile in <code>./buildFiles/prologue</code>.</p>"},{"location":"deployment/#build-the-docker-images","title":"Build the docker images","text":"<p>With the dockerfiles ready, we can create the images via the following commands from the applications root directory:</p> <pre><code>#!/bin/sh\n# Creates your image\nsudo docker build --file ./buildFiles/nginx/dockerfile --tag &lt;NGINX_IMAGE_NAME&gt; ./buildFiles/nginx\nsudo docker build --file ./buildFiles/nimstoryfont/dockerfile --tag &lt;PROLOGUE_IMAGE_NAME&gt; ./buildFiles/nimstoryfont\n\n# Stores your images in your current working directory\nsudo docker save -o nginx-image.tar &lt;NGINX_IMAGE_NAME&gt; \nsudo docker save -o prologue-image.tar &lt;PROLOGUE_IMAGE_NAME&gt;\n</code></pre> <p>Once created, move that image file to your server, e.g. via <code>scp</code>.</p>"},{"location":"deployment/#run-the-docker-image-on-your-server_1","title":"Run the docker image on your server","text":"<p>After copying your <code>docker-compose.yml</code>, the <code>nginx-image.tar</code> and the <code>prologue-image.tar</code> to your server, you can deploy your application.</p> <p>Simply load the images into docker and run <code>docker-compose up</code> (or <code>docker-compose restart</code>). There is no need to specify volumes or ports, as that is already in the <code>docker-compose.yml</code>.</p> <p>You may want to write yourself a small script that loads the images and restarts: <pre><code>#!/bin/sh\nsudo docker load -i &lt;NGINX_IMAGE_NAME&gt;.tar\nsudo docker load -i &lt;PROLOGUE_IMAGE_NAME&gt;.tar\n\nsudo docker-compose restart\n</code></pre></p> <p>Run the command and your containers will start up and be accessible via HTTP and HTTPS!</p>"},{"location":"deployment/#known-issues","title":"Known issues","text":""},{"location":"deployment/#compile-your-binary-under-bitnamiminideb-error-libx86_64-linux-gnulibcso6-version-glibc_xxx-not-found","title":"Compile your binary (under <code>bitnami/minideb</code> - <code>error \"/lib/x86_64-linux-gnu/libc.so.6: version 'GLIBC_&lt;X.XX&gt;' not found\"</code>","text":"<p>You will run into this issue if your local <code>glibc</code> version is more up-to-date than the one <code>bitnami/minideb</code> has access to. This is the case because during compilation your binary is dynamically linked with your local <code>glibc</code> version. That means in order to run, it expects the environment that executes it to have at least that same glibc version.</p> <p>To fix this, you need to link your binary to an older glibc version when compiling, even though your own version is newer. Doing so is not straightforward.</p>"},{"location":"deployment/#solution-1-using-zig","title":"Solution 1: Using zig","text":"<p>The simplest way is installing the compiler og the zig programming language, as it contains a Clang compiler, which you can tell which glibc version to use.</p> <p>The steps go as follows:</p> <ul> <li>Install zig</li> <li>Write a bashscript called <code>zigcc</code></li> </ul> <pre><code>#!/bin/sh\nzig cc $@\n</code></pre> <ul> <li>Move <code>zigcc</code> to somewhere on your path, e.g. <code>/usr/local/bin</code>. This is required since the nim compiler does not tolerate spaces in commands that call compilers.</li> <li>Write yourself a bashscript with a command to compile your project.  This can't be done via nimble tasks since the syntax is not allowed within nimble tasks. Replace the \"X.XX\" with the glibc version that you want as well as the other placeholders.</li> </ul> <pre><code>#!/bin/sh\n# Call this file projectCompile.sh\nnim c \\\n--cc:clang \\\n--clang.exe=\"zigcc\" \\\n--clang.linkerexe=\"zigcc\" \\\n--passC:\"-target x86_64-linux-gnu.X.XX -fno-sanitize=undefined\" \\\n--passL:\"-target x86_64-linux-gnu.X.XX -fno-sanitize=undefined\" \\\n--forceBuild:on \\\n--opt:speed \\\n--deepcopy:on \\\n--mm:orc \\\n--define:release \\\n--define:lto \\\n--define:ssl \\\n--outdir:\".\" \\\nsrc/&lt;YOUR_MAIN_FILE&gt;.nim\n</code></pre> <ul> <li>Run projectCompile.sh</li> </ul>"},{"location":"deployment/#solution-2-create-a-compilation-environment","title":"Solution 2: Create a compilation environment","text":"<p>Instead of using zig, you can set up a second docker container that contains the glibc version you want, gcc, nim, nimble and the C-libs you require.  You can then mount your project-folder via docker volume in the container and compile as normal. Then, you can just compile your binary within the container as usual, your normal compilation command.</p>"},{"location":"errorhandler/","title":"Error Handler","text":""},{"location":"errorhandler/#user-defined-error-pages","title":"User-defined error pages","text":"<p>When web application encounters some unexpected situations, it may send 404 response to the client. You may want to use user-defined 404 pages, then you can use <code>resp</code> to return 404 response.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  resp \"Something is wrong, please retry.\", Http404\n</code></pre> <p><code>Prologue</code> also provides an <code>error404</code> helper function to create a 404 response.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  resp error404(headers = ctx.response.headers)\n</code></pre> <p>Or use <code>errorPage</code> to create a more descriptive error page.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  resp errorPage(\"Something is wrong\"), Http404\n</code></pre>"},{"location":"errorhandler/#default-error-handler","title":"Default error handler","text":"<p>Users can also set the default error handler. When <code>ctx.response.body</code> is empty, web application will use the default error handler.</p> <p>The basic example with <code>respDefault</code> which is equal to <code>resp errorPage(\"Something is wrong\"), Http404</code>.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  respDefault Http404\n</code></pre> <p><code>Prologue</code> has registered two error handlers before application starts, namely <code>default404Handler</code> for <code>Http404</code> and <code>default500Handler</code> for <code>Http500</code>. You can change them using <code>registerErrorHandler</code>.</p> <pre><code>proc go404*(ctx: Context) {.async.} =\n  resp \"Something wrong!\", Http404\n\nproc go20x*(ctx: Context) {.async.} =\n  resp \"Ok!\", Http200\n\nproc go30x*(ctx: Context) {.async.} =\n  resp \"EveryThing else?\", Http301\n\napp.registerErrorHandler(Http404, go404)\napp.registerErrorHandler({Http200 .. Http204}, go20x)\napp.registerErrorHandler(@[Http301, Http304, Http307], go30x)\n</code></pre> <p>If you don't want to use the default Error handler, you could clear the whole error handler table.</p> <pre><code>var app = newApp(errorHandlerTable = newErrorHandlerTable())\n</code></pre>"},{"location":"errorhandler/#http-500-handler","title":"HTTP 500 handler","text":"<p><code>Http 500</code> indicates the internal error of the framework. In debug mode(<code>settings.debug = true</code>), the framework will send the exception msgs to the web browser if the length of error msgs is greater than zero.  Otherwise, the framework will use the default error handled which has been registered before the application starts. Users could cover this handler by using their own error handler.</p>"},{"location":"event/","title":"Event","text":"<p><code>Prologue</code> supports both <code>startup</code> and <code>shutdown</code> events. <code>startup</code> events will be only executed once for each thread. In contrast, <code>shutdown</code> events will be executed once after the main loop.</p> <p>Let's first look at the structure of <code>Event</code>, you can see that <code>Event</code> supports both synchronous and asynchronous closure function pointers.</p> <pre><code>type\n  AsyncEvent* = proc(): Future[void] {.closure, gcsafe.}\n  SyncEvent* = proc() {.closure, gcsafe.}\n\n  Event* = object\n    case async*: bool\n    of true:\n      asyncHandler*: AsyncEvent\n    of false:\n      syncHandler*: SyncEvent\n</code></pre> <p>You can use <code>initEvent</code> and pass function pointers to create <code>Event</code>.</p> <pre><code>proc initEvent*(handler: AsyncEvent): Event {.inline.} =\n  Event(async: true, asyncHandler: handler)\n\nproc initEvent*(handler: SyncEvent): Event {.inline.} =\n  Event(async: false, syncHandler: handler)\n</code></pre> <p><code>newApp</code> has <code>startup</code> and <code>shutdown</code> parameters. You can pass a sequence of events to <code>newApp</code>.</p> <pre><code>proc newApp*(settings: Settings, middlewares: sink seq[HandlerAsync] = @[],\n             startup: seq[Event] = @[], shutdown: seq[Event] = @[],\n             errorHandlerTable = DefaultErrorHandler,\n             appData = newStringTable(mode = modeCaseSensitive)): Prologue =\n</code></pre> <p>Here is an example for a <code>startup</code> event (A <code>shutdown</code> event has the same usage as a <code>startup</code> event).</p> <pre><code>proc setLoggingLevel() =\n  addHandler(newConsoleLogger())\n  logging.setLogFilter(lvlInfo)\n\n\nlet \n  event = initEvent(setLoggingLevel)\n\nvar\n  app = newApp(settings = settings, startup = @[event])\n</code></pre>"},{"location":"extendctx/","title":"Extend Context","text":"<p><code>Prologue</code> provides flexible way to extend <code>Context</code> object. User-defined <code>Context</code> should inherit from the <code>Context</code> object.</p>"},{"location":"extendctx/#a-simple-example","title":"A simple example","text":"<p>The following example shows how to make a <code>UserContext</code> object which contains a new data member of <code>int</code> type. You should use <code>extend</code> method to initialize the new attributes. Finally use <code>app.run(UserContext)</code> to register the type.</p> <pre><code>import prologue\n\ntype\n  UserContext = ref object of Context\n    data: int\n\n# initialize data\nmethod extend(ctx: UserContext) {.gcsafe.} =\n  ctx.data = 999\n\nproc hello*(ctx: Context) {.async.} =\n  let ctx = UserContext(ctx)\n  doAssert ctx.data == 999\n  resp \"&lt;h1&gt;Hello, Prologue!&lt;/h1&gt;\"\n\nvar app = newApp()\napp.get(\"/\", hello)\napp.run(UserContext)\n</code></pre>"},{"location":"extendctx/#make-a-middleware-for-personal-use","title":"Make a middleware for personal use","text":"<pre><code>import prologue\n\ntype\n  UserContext = ref object of Context\n    data: int\n\nproc init(ctx: UserContext) =\n  ctx.data = 12\n\nproc experimentMiddleware(): HandlerAsync =\n  result = proc(ctx: Context) {.async.} =\n    let ctx = UserContext(ctx)\n    doAssert ctx.data == 12\n    inc ctx.data\n    await switch(ctx)\n\nmethod extend(ctx: UserContext) {.gcsafe.} =\n  init(ctx)\n\nproc hello*(ctx: Context) {.async.} =\n  let ctx = UserContext(ctx)\n  assert ctx.data == 13\n  echo ctx.data\n  resp \"&lt;h1&gt;Hello, Prologue!&lt;/h1&gt;\"\n\nvar app = newApp()\napp.use(experimentMiddleware())\napp.get(\"/\", hello)\napp.run(UserContext)\n</code></pre>"},{"location":"extendctx/#make-a-general-purpose-middleware","title":"Make a general purpose middleware","text":"<p>Notes: use prefix or suffix denoting data member to avoid conflicts with other middlewares.</p> <pre><code># middleware for general purpose\ntype\n  ExperimentContext = concept ctx\n    ctx is Context\n    ctx.data is int\n\nproc init[T: ExperimentContext](ctx: T) =\n  ctx.data = 12\n\nproc experimentMiddleware[T: ExperimentContext](ctxType: typedesc[T]): HandlerAsync =\n  result = proc(ctx: Context) {.async.} =\n    let ctx = ctxType(ctx)\n    doAssert ctx.data == 12\n    inc ctx.data\n    await switch(ctx)\n\n\ntype\n  UserContext = ref object of Context\n    data: int\n\nmethod extend(ctx: UserContext) {.gcsafe.} =\n  init(ctx)\n\nproc hello*(ctx: Context) {.async.} =\n  let ctx = UserContext(ctx)\n  assert ctx.data == 13\n  echo ctx.data\n  resp \"&lt;h1&gt;Hello, Prologue!&lt;/h1&gt;\"\n\nvar app = newApp()\napp.use(experimentMiddleware(UserContext))\napp.get(\"/\", hello)\napp.run(UserContext)\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#threads","title":"Threads","text":"<p><code>Prologue</code> supports two HTTP server: <code>httpbeast</code> and <code>asynchttpserver</code>. If you are in Linux or MacOS, use <code>--threads:on</code> to enable the multi-threads HTTP server. If you are in windows, <code>threads</code> should not be used. You can use <code>-d:usestd</code> to switch to <code>asynchttpserver</code> in Linux or MacOS.</p>"},{"location":"faq/#benchmarking-and-debug","title":"Benchmarking and debug","text":"<p>If you want to benchmark <code>prologue</code> or release you programs, make sure set <code>settings.debug</code> = false.</p> <pre><code>let\n  # debug attributes must be false\n  env = loadPrologueEnv(\".env\")\n  settings = newSettings(appName = env.getOrDefault(\"appName\", \"Prologue\"),\n                         debug = false,\n                         port = Port(env.getOrDefault(\"port\", 8080)),\n                         secretKey = env.getOrDefault(\"secretKey\", \"\")\n    )\n</code></pre> <p>or in <code>.env</code> file, set <code>debug = false</code>.</p> <pre><code># Don't commit this to source control.\n# Eg. Make sure \".env\" in your \".gitignore\" file.\ndebug=false # change this\nport=8080\nappName=HelloWorld\nstaticDir=/static\nsecretKey=Pr435ol67ogue\n</code></pre>"},{"location":"faq/#disable-logging","title":"Disable logging","text":"<p>There are two ways to disable logging messages:</p> <ul> <li>set <code>settings.debug</code> = false</li> <li>set a startup event</li> </ul> <pre><code>proc setLoggingLevel() =\n  addHandler(newConsoleLogger())\n  logging.setLogFilter(lvlInfo)\n\n\nlet \n  event = initEvent(setLoggingLevel)\nvar\n  app = newApp(settings = settings, startup = @[event])\n</code></pre>"},{"location":"faq/#avoid-using-a-function-name-which-is-same-to-the-module-name","title":"Avoid using a function name which is same to the module name.","text":"<p><code>src/index.nim</code></p> <pre><code>proc index(ctx: Context) {.async.} =\n  ...\n</code></pre>"},{"location":"faq/#use-the-full-path-of-js-css-files","title":"Use the full path of JS, CSS files.","text":"<p>For instance in your HTML file use <code>templates/some.js</code> instead of <code>some.js</code>.</p>"},{"location":"faq/#run-in-async-mode","title":"Run in async mode","text":"<p>The server can run in async mode, this is useful to perform other tasks beside accepting connections.</p> <pre><code>import prologue\n\nproc handler(ctx: Context) {.async.} =\n  resp \"Hello world\"\n\nlet settings = newSettings(port = Port(8000))\nlet app = newApp(settings)\napp.all(\"/*$\", handler)\nwaitFor app.runAsync()\n</code></pre>"},{"location":"headers/","title":"Headers","text":"<p>Prologue provides two types of <code>headers</code>. One is the headers of <code>request</code> which carries information from the client. The other is the headers of <code>response</code> which carries information sent to the client.</p>"},{"location":"headers/#the-headers-of-the-request","title":"The headers of the request","text":"<p>The client will send headers to our HTTP server. You may want to check whether some keys are in the headers.  If existing, you could get the values of them. The return type of <code>ctx.request.getHeader</code> is <code>seq[string]</code>. You often only need the first element of the sequence.</p> <p>The following code first checks whether the key exists in headers. If true, retrieve the sequence of values and display them in the browser.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  if ctx.request.hasHeader(\"cookie\"):\n    let values = ctx.request.getHeader(\"cookie\")\n    resp $values\n  elif ctx.request.hasHeader(\"content-type\"):\n    let values = ctx.request.getHeaderOrDefault(\"content\")\n    resp $values\n</code></pre>"},{"location":"headers/#the-headers-of-the-response","title":"The headers of the response","text":"<p><code>Prologue</code> also sends HTTP headers to the client. It uses <code>ResponseHeaders</code> to store them. It has similar API like the headers of the request. First, <code>Prologue</code> initializes <code>ctx.response</code> with <code>initResponseHeaders</code>. Then  users could use <code>hasHeader</code>, <code>addHeader</code> or <code>setHeader</code> to do what they want. </p> <p>Notes that, <code>addHeader</code> will append values to existing keys in headers. <code>setHeader</code> will reset the values of key no matter whether key is in the headers. </p> <pre><code>proc hello(ctx: Context) {.async.} =\n  ctx.response.addHeader(\"Content-Type\", \"text/plain\")\n\n  doAssert ctx.response.getHeader(\"CONTENT-TYPE\") == @[\n        \"text/html; charset=UTF-8\", \"text/plain\"]\n\n  ctx.response.setHeader(\"Content-Type\", \"text/plain\")\n\n  doAssert ctx.response.getHeader(\"CONTENT-TYPE\") == @[\n      \"text/html; charset=UTF-8\", \"text/plain\"]\n</code></pre>"},{"location":"middleware/","title":"Middlewares","text":""},{"location":"middleware/#existing-middlewares","title":"Existing middlewares","text":"<p>Prologue provides various middlewares out of the box.</p>"},{"location":"middleware/#static-file-serving","title":"Static File Serving","text":"<p>Allows serving files directly from the prologue webserver. It is recommended to only use this during development, as serving static files (e.g. images) is typically done by the reverse proxy server in production.</p> <p>Please note that the filepaths you specify there are relative to the position of the binary, so where you place the binary from matters!</p> <p>If you run the lower example locally on port 8080, a file in the folder <code>media/image.png</code> will be served on the URL <code>localhost:8080/media/image.png</code></p> <pre><code>import prologue\nimport prologue/middlewares/staticfile\n\nvar app = newApp()\napp.use(staticFileMiddleware(\"media\")) # \napp.run()\n</code></pre>"},{"location":"middleware/#write-your-own-middleware","title":"Write your own middleware","text":"<p>Middlewares are like an onion.</p> <pre><code>a request -&gt; middlewareA does something -&gt; middlewareB does something\n-&gt; handler does something -&gt; middlewareB does something -&gt; middlewareA does something -&gt; a response\n</code></pre> <p>Don't forget <code>await switch(ctx)</code> to enter the next middleware or handler.</p> <p>Then you can set global middlewares which are visible to all handlers. Or you can make them only visible to some middlewares.</p> <pre><code>import logging\nimport prologue\n\n\nproc hello(ctx: Context) {.async.} =\n  discard\n\nproc myDebugRequestMiddleware*(appName = \"Prologue\"): HandlerAsync =\n  result = proc(ctx: Context) {.async.} =\n    logging.info \"debugRequestMiddleware-&gt;begin\"\n    # do something before\n    await switch(ctx)\n    # do something after\n    logging.info \"debugRequestMiddleware-&gt;End\"\n\n\nvar app = newApp()\n\napp.use(myDebugRequestMiddleware())\napp.addRoute(\"/\", hello, HttpGet, middlewares = @[myDebugRequestMiddleware()])\n</code></pre> <p>You can also put some variables in closure environments, but be careful it is error-prone when using multi-threads. You must know the differences between GC options(thread local heap vs shared heap) and what's the use of <code>gcsafe</code>. </p> <pre><code>proc sessionMiddleware(): HandleAsync =\n  var memorySessionTable = newTable[string, string]()\n\n  result = proc(ctx: Context) {.async.} =\n    memorySessionTable[\"test\"] = \"prologue\"\n</code></pre> <p>You can put your middleware plugin in collections.</p>"},{"location":"middleware/#write-reusable-handler","title":"Write reusable handler","text":"<p>Every handler in <code>Prologue</code> is a closure function. It is flexible to create a reusable components.</p> <pre><code>import prologue\n\n\nproc home(ctx: Context) {.async.} =\n  resp \"home\"\n\nproc redirectTo(\n  dest: string\n): HandlerAsync =\n  result = proc(ctx: Context) {.async.} =\n    resp redirect(dest)\n\n\nvar app = newApp()\napp.get(\"/\", home)\napp.get(\"/redirect\", redirectTo(\"/\"))\napp.run()\n</code></pre>"},{"location":"middleware/#use-built-in-middleware","title":"Use built-in middleware","text":"<p><code>prologue</code> also supplies some middleware plugins, you can directly import <code>middlewares</code>.</p> <p>It contains <code>cors</code>, <code>clickjacking</code>, <code>csrf</code>, <code>utils</code> and <code>auth</code> middlewares.</p> <pre><code>import prologue/middlewares\n</code></pre> <p>For better compilation time, you could import them directly.</p> <pre><code>import prologue/middlewares/auth\n# or\nimport prologue/middlewares/utils\n# or\nimport prologue/middlewares/cors\n# or\nimport prologue/middlewares/clickjacking\n# or\nimport prologue/middlewares/csrf\n</code></pre> <p>For session middlewares, you need to import them directly.</p> <pre><code>import prologue/middlewares/memorysession\n# or\nimport prologue/middlewares/redissession\n# or\nimport prologue/middlewares/signedcookiesession\n</code></pre>"},{"location":"mocking/","title":"Mocking","text":"<p>Mocking module can be used for quick test without HTTP server.</p> <p>First use <code>mockApp</code> to add <code>mockingMiddleware</code> to the application. Next create a new mocking request using <code>initMockingRequest</code>. Then run the mocking application with <code>runOnce</code>. Finally check whether <code>ctx</code> meets your requirements.</p> <pre><code>import prologue\nimport prologue/mocking\n\nimport std/uri\n\n\nproc hello*(ctx: Context) {.async.} =\n  resp \"&lt;h1&gt;Hello, Prologue!&lt;/h1&gt;\"\n\n\nlet settings = newSettings(debug = true)\nvar app = newApp(settings = settings)\napp.addRoute(\"/\", hello)\n\nmockApp(app)\n\n\nlet url = parseUri(\"/\")\n\nlet req = initMockingRequest(\n  httpMethod = HttpGet,\n  headers = newHttpHeaders(),\n  url = url,\n  cookies = initCookieJar(),\n  postParams = newStringTable(),\n  queryParams = newStringTable(),\n  formParams = initFormPart(),\n  pathParams = newStringTable()\n)\n\nlet ctx = app.runOnce(req)\n\ndoAssert ctx.response.code == Http200\ndoAssert ctx.response.getHeader(\"content-type\") == @[\"text/html; charset=UTF-8\"]\ndoAssert ctx.response.body == \"&lt;h1&gt;Hello, Prologue!&lt;/h1&gt;\"\n</code></pre>"},{"location":"openapi/","title":"openapi","text":"<p><code>Prologue</code> supplies minimal supports for <code>openapi</code> docs. You need to write <code>openapi.json</code> by yourself. Then <code>Prologue</code> will register corresponding routes.</p> <pre><code>import prologue\nimport prologue/openapi\n\n\napp.serveDocs(\"docs/openapi.json\")\napp.run()\n</code></pre> <p>example for <code>docs/openapi.json</code>.</p> <p>visit <code>localhost:8080/docs</code> or <code>localhost:8080/redocs</code></p> <p></p>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#hello-world","title":"Hello World","text":"<p>Now Let's begin a quick tour of <code>Prologue</code>.</p> <pre><code># app.nim\nimport prologue\n\nproc hello*(ctx: Context) {.async.} =\n  resp \"&lt;h1&gt;Hello, Prologue!&lt;/h1&gt;\"\n\nvar app = newApp()\napp.addRoute(\"/\", hello)\napp.run()\n</code></pre> <p>This is a very basic \"Hello Prologue\" example. Run this script, then visit http://localhost:8080 and you will see \"Hello, Prologue!\" in your browser! Here is how it works.</p> <p>First we <code>import prologue</code> to include all things we need in this example(for examples <code>resp</code> macros).</p> <p>Then let's look at <code>hello</code> function. It generates html or plain text or json or something else sent to our HTTP server. The parameter <code>ctx</code> is of <code>Context</code> type. <code>Context</code> carries all things which we can use in our handler in each request. It contains <code>request</code> information from HTTP server, <code>response</code> information which we transfer to HTTP server Correspondingly and other useful attributes. In the body of function, we can find <code>resp</code> macros. <code>resp</code> is handy for generating response we need. It is equal to <code>ctx.response = initResponse(\"&lt;h1&gt;Hello, Prologue!&lt;/h1&gt;\")</code>.</p> <p>Next let's configure our application. For this basic example, we use default settings. You can specify parameters of <code>newSettings</code> too. For example change <code>port</code> attribute or set <code>debug</code> flag.</p> <p>Next add route to our application. <code>\"/\"</code> is the URL we can visit in the web browser. <code>Hello</code> is the handler which processes the request from the web browser and sends <code>\"&lt;h1&gt;Hello, Prologue!&lt;/h1&gt;\"</code> to the web browser.</p> <p>Finally use <code>nim c -r app.nim</code> to run our application. Visit <code>localhost:8080</code>, <code>Hello, Prologue!</code> is displayed in your browser.</p> <p></p>"},{"location":"quickstart/#command-line-tool","title":"Command Line Tool","text":"<p><code>logue</code> can be used to initialize your program.</p> <p>Make sure <code>~/.nimble/bin</code> is in your environment variables.</p> <p>Type command <code>logue init helloworld</code> to initialize a new project. This will create a program structure like this:</p> <pre><code>- helloworld\n  - .env\n  - app.nim\n  - urls.nim\n  - views.nim\n</code></pre> <p>You must switch to <code>/.../helloworld</code> directory to run <code>app.nim</code>. For example, you can type <code>logue run</code> and open the browser to visit the URL.</p>"},{"location":"quickstart/#debug-mode","title":"Debug Mode","text":"<p>There are many ways to enable debug mode. If using default settings, debug mode is enabled too. You can also enable them on your own.</p> <pre><code>let settings = newSettings(debug = true)\n</code></pre> <p>If you use JSON config file:</p> <pre><code>{\n  \"prologue\": {\n    \"address\": \"\",\n    \"port\": 8080,\n    \"debug\": true,\n    \"reusePort\": true,\n    \"appName\": \"\",\n    \"secretKey\": \"Set by yourself\",\n  }\n}\n</code></pre> <p>Set <code>debug = false</code> to disable debug mode.</p> <p>Once debug mode is enabled, the program will display useful logging messages. It is helpful for debugging. But it will slow down the program. If you want to benchmark or release your program, please set <code>debug = false</code>.</p>"},{"location":"quickstart/#url-building","title":"URL Building","text":"<p><code>Prologue</code> provides a special function <code>urlFor</code> to get the URL from the name of handler. Before using <code>urlFor</code>, you should register the name of handler first.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  resp ctx.urlFor(\"index\")\n\nproc index(ctx: Context) {.async.} =\n  resp \"Hello world\"\n\n\nvar app = newApp()\napp.get(\"/hello\", hello)\napp.get(\"/index\", index, name = \"index\")\n</code></pre> <p>If you visit <code>localhost:8080/hello</code>, the browser will display <code>/index</code> on the screen. <code>urlFor</code> only supports two forms of Route: 1. <code>/route/hello</code> 2. <code>/route/{parameter}/other</code>. So you can also pass parameters to <code>urlFor</code>. For example <code>urlFor(\"route\", {\"parameter\": \"think\"})</code> will build <code>/route/think/other</code>. It also supports passing query parameters.</p>"},{"location":"quickstart/#static-files","title":"Static Files","text":"<p>You may want to serve your HTML, CSS files. Static files middleware can be used for this purpose. You should put your static files under <code>/public</code> directory.</p> <pre><code>import prologue\nimport prologue/middlewares/staticfile\n\napp.use(staticFileMiddleware(\"/public\"))\n</code></pre>"},{"location":"quickstart/#redirect","title":"Redirect","text":"<p>You can easily redirect to other URL using <code>redirect</code> function. The default HTTP code for <code>redirct</code> function is Http301. You could use Http302 to move temporarily.</p> <p>The program below redirects to <code>localhost:8080/home</code>.</p> <pre><code>proc redirectHome*(ctx: Context) {.async.} =\n  resp redirect(\"/home\")\n</code></pre>"},{"location":"quickstart/#cookies","title":"Cookies","text":"<p><code>Prologue</code> provides <code>setCookie</code>, <code>deleteCookie</code> and <code>getCookie</code> to help you with cookies.</p> <p>The handler below will display the name in the cookies from the client if existing. Otherwise <code>AnyOne</code> will be displayed.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  resp ctx.getCookie(\"name\", \"Anyone\")\n</code></pre> <p><code>setCookie</code> sets the (key, value) pair in the HTTP headers. You could also set the <code>expires</code> or <code>maxAge</code> of the cookies. These attributes decide when the survival time of the cookies. <code>deleteCookie</code> will make the specific key expired at once.</p>"},{"location":"request/","title":"Request","text":"<p><code>Request</code> contains the information from the HTTP server. You can visit this attribute by using <code>ctx.request</code>.</p> <p>For example If you want to get state from users, query the <code>cookies</code> attribute.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  if ctx.request.cookies.hasKey(\"happy\"):\n    echo \"Yea, I'm happy\"\n</code></pre>"},{"location":"request/#request-utils","title":"Request utils","text":""},{"location":"request/#requesturl","title":"request.url","text":"<p>Gets the url of the request.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  echo ctx.request.url\n</code></pre>"},{"location":"request/#requestport","title":"request.port","text":"<p>Gets the port of the request.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  echo ctx.request.port.int\n</code></pre>"},{"location":"request/#requestpath","title":"request.path","text":"<p>Gets the path of the request.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  echo ctx.request.path\n</code></pre>"},{"location":"request/#requestreqmethod","title":"request.reqMethod","text":"<p>Gets the <code>HttpMethod</code> of the request.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  echo ctx.request.reqMethod\n</code></pre>"},{"location":"request/#requestcontenttype","title":"request.contentType","text":"<p>Gets the contentType of the request.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  echo ctx.request.contentType\n</code></pre>"},{"location":"request/#requesthostname","title":"request.hostName","text":"<p>Gets the hostname of the request.</p> <pre><code>proc hello(ctx: Context) {.async.} =\n  echo ctx.request.hostName\n</code></pre>"},{"location":"response/","title":"Response","text":""},{"location":"response/#respond-by-types","title":"Respond by types","text":"<p>You can specify different responses by types.</p> <ul> <li>htmlResponse -&gt; HTML format <pre><code>import prologue\n\n# this proc will return an html response to the client\nproc response*(ctx: Context) {.async.} =\n  resp htmlResponse(\"&lt;h1&gt;Hello, Prologue!&lt;/h1&gt;\")\n\nlet app = newApp()\napp.addRoute(\"/\", response)\napp.run()\n</code></pre></li> <li>plainTextResponse -&gt; Plain Text format <pre><code>import prologue\n\n# this proc will return plain text to the client\nproc response*(ctx: Context) {.async.} =\n  resp plainTextResponse(\"Hello, Prologue!\")\n\nlet app = newApp()\napp.addRoute(\"/\", response)\napp.run()\n</code></pre></li> <li>jsonResponse -&gt; Json format <pre><code>import prologue, std/json\n\n# this proc will return json to the client\nproc response*(ctx: Context) {.async.} =\n  # the %* operator creates json from nim types. more info: https://nim-lang.org/docs/json.html\n  var info = %* \n    [\n      { \"name\": \"John\", \"age\": 30 },\n      { \"name\": \"Susan\", \"age\": 45 }\n    ]\n\n  resp jsonResponse(info)\n\nlet app = newApp()\napp.addRoute(\"/\", response)\napp.run()\n</code></pre></li> </ul>"},{"location":"response/#respond-by-error-code","title":"Respond by error code","text":"<ul> <li>error404 -&gt; return 404</li> <li>redirect -&gt; return 301 and redirect to a new page</li> <li>abort -&gt; return 401</li> </ul>"},{"location":"response/#other-utils","title":"Other utils","text":"<p>You can set the cookie and header of the response.</p> <p><code>SetCookie</code>: sets the cookie of the response. <code>DeleteCookie</code>: deletes the cookie of the response. <code>setHeader</code>: sets the header values of the response. <code>addHeader</code>: adds header values to the existing <code>HttpHeaders</code>.</p>"},{"location":"response/#send-user-defined-response","title":"Send user-defined response","text":"<p><code>Prologue</code> framework will automatically send the final response to the client. You just need to set the attributes of response.</p> <p>It also supports sending response by yourself. For example you can use <code>ctx.respond</code> to send data to the client.</p> <pre><code>proc sendResponse(ctx: Context) {.async.} =\n  await ctx.respond(Http200, \"data\")\n</code></pre> <p>But this will leads that \"data\" message is sent twice, it's ok for some situations. For example, you may want to send another message, you can change the body of the response. </p> <pre><code>proc sendResponse(ctx: Context) {.async.} =\n  await ctx.respond(Http200, \"data\")\n  ctx.response.body = \"message\"\n</code></pre> <p>First this handler will send \"data\" to the client, then the handler will send \"message\" to the client. However, this may be not the intended behaviour. You want to make sure when you send response by yourself, the framework shouldn't handle the response anymore.</p> <p>You can set the <code>handled</code> attribute of context to true. Now the framework won't handle <code>ctx.response</code> any more and the error handler won't handle the response too. Only the \"data\" message is sent to the client.</p> <pre><code>proc sendResponse(ctx: Context) {.async.} =\n  await ctx.respond(Http200, \"data\")\n  ctx.handled = true\n  ctx.response.code = Http500\n  ctx.response.body = \"message\"\n</code></pre>"},{"location":"routing/","title":"Routing","text":"<p>Routing is the core of web framework.</p>"},{"location":"routing/#static-routing","title":"Static Routing","text":"<p>Registering handler <code>hello</code> by specifying path, HTTP methods and middlewares.</p> <p><code>HttpGet</code> is the default HTTP methods. If you have registered a handler with <code>HttpGet</code>, <code>Prologue</code> will automatically register <code>HttpHead</code> for this handler.</p> <pre><code># handler\nimport prologue\n\n\nproc hello*(ctx: Context) {.async.} =\n  resp \"&lt;h1&gt;Hello, Prologue!&lt;/h1&gt;\"\n\n\nvar app = newApp()\napp.addRoute(\"/hello\", hello)\n# or\n# app.get(\"/hello\", hello)\napp.run()\n</code></pre> <p>You can also use <code>seq[HttpMethod]</code> to register the same handler but supports multiple HTTP methods.</p> <pre><code>import prologue\n\n\n# handler\nproc hello*(ctx: Context) {.async.} =\n  resp \"&lt;h1&gt;Hello, Prologue!&lt;/h1&gt;\"\n\nvar app = newApp()\napp.addRoute(\"/hello\", hello, @[HttpGet, HttpPost])\napp.run()\n</code></pre>"},{"location":"routing/#parameters-routing","title":"Parameters Routing","text":"<p><code>Prologue</code> supports parameters route. You can use <code>getPathParams</code> to get named arguments.</p>"},{"location":"routing/#basic-example","title":"Basic Example","text":"<pre><code>import prologue\n\n\nproc hello*(ctx: Context) {.async.} =\n  resp \"&lt;h1&gt;Hello, \" &amp; ctx.getPathParams(\"name\", \"Prologue\") &amp; \"&lt;/h1&gt;\"\n\nvar app = newApp()\napp.addRoute(\"/hello/{name}\", hello, HttpGet)\napp.run()\n</code></pre>"},{"location":"routing/#wildcard","title":"Wildcard","text":"<p>Wildcard will match only one URL section. For examples, <code>/static/*</code> only match <code>/static/static.css</code>, <code>/static/etc</code> and so on. You should use greedy(<code>$</code>) character to match multiple URL sections.</p> <pre><code>import prologue\n\n\nproc hello*(ctx: Context) {.async.} =\n  resp \"Hello, Prologue\"\n\nvar app = newApp()\napp.get(\"/static/*\", hello)\napp.get(\"/*/static\", hello)\napp.get(\"/static/templates/{path}/*\", hello)\napp.run()\n</code></pre>"},{"location":"routing/#greedy","title":"Greedy","text":"<p>Greedy character(<code>$</code>) will match all the remaining URL sections. But it can only used at the end of the URL. <code>RouteError</code> will be raised if it is used in the middle of the URL.</p> <p>For <code>/test/{param}$</code>, <code>/test/foo/bar/baz/</code> is matched. The path parameter is \"foo/bar/baz\". For <code>/test/*$</code>, <code>/test/static/foo/bar/baz/</code> is matched.</p> <pre><code>import prologue\n\n\nproc hello*(ctx: Context) {.async.} =\n  resp \"Hello, Prologue\"\n\nvar app = newApp()\napp.get(\"/test/{param}$\", hello)\napp.get(\"/test/static/*$\", hello)\napp.run()\n</code></pre>"},{"location":"routing/#regex-routing","title":"Regex Routing","text":"<p><code>Prologue</code> supports regex route.</p> <pre><code>import prologue\n\n\nproc articles*(ctx: Context) {.async.} =\n  resp $ctx.getPathParams(\"num\", 1)\n\nvar app = newApp()\napp.addRoute(re\"/post(?P&lt;num&gt;[\\d]+)\", articles, HttpGet)\napp.run()\n</code></pre>"},{"location":"routing/#pattern-routing","title":"Pattern Routing","text":"<pre><code>import prologue\n\nproc hello(ctx: Context) {.async.} =\n  resp \"Hello World!\"\n\nconst urlPatterns = @[\n  pattern(\"/hello\", hello)\n]\n\nvar app = newApp()\n\napp.addRoute(urlPatterns, \"\")\napp.run()\n</code></pre>"},{"location":"routing/#group-routing","title":"Group Routing","text":"<p><code>Prologue</code> supports group route. You can add arbitrary levels of route.</p> <pre><code>import prologue\n\n\nvar\n  app = newApp()\n  base = newGroup(app, \"/apiv2\", @[])\n  level1 = newGroup(app,\"/level1\", @[], base)\n  level2 = newGroup(app, \"/level2\", @[], level1)\n  level3 = newGroup(app, \"/level3\", @[], level2)\n\n\nproc hello(ctx: Context) {.async.} =\n  resp \"Hello\"\n\nproc hi(ctx: Context) {.async.} =\n  resp \"Hi\"\n\nproc home(ctx: Context) {.async.} =\n  resp \"Home\"\n\n# /apiv2/hello\nbase.get(\"/hello\", hello)\nbase.get(\"/hi\", hi)\nbase.post(\"/home\", home)\n\n\n# /apiv2/level1/hello\nlevel1.get(\"/hello\", hello)\nlevel1.get(\"/hi\", hi)\nlevel1.post(\"/home\", home)\n\n# /apiv2/level1/level2/hello\nlevel2.get(\"/hello\", hello)\nlevel2.get(\"/hi\", hi)\nlevel2.post(\"/home\", home)\n\n# /apiv2/level1/level2/level3/hello\nlevel3.get(\"/hello\", hello)\nlevel3.get(\"/hi\", hi)\nlevel3.post(\"/home\", home)\n\napp.run()\n</code></pre> <p><code>std/with</code> provides a more neat routing fashion:</p> <pre><code>import prologue\nimport std/with\n\n\nvar \n  app = newApp()\n  base = newGroup(app, \"/apiv2\", @[])\n  level1 = newGroup(app,\"/level1\", @[], base)\n  level2 = newGroup(app, \"/level2\", @[], level1)\n  level3 = newGroup(app, \"/level3\", @[], level2)\n\n\nproc hello(ctx: Context) {.async.} =\n  resp \"Hello\"\n\nproc hi(ctx: Context) {.async.} =\n  resp \"Hi\"\n\nproc home(ctx: Context) {.async.} =\n  resp \"Home\"\n\n\nwith base:\n  get(\"/hello\", hello)\n  get(\"/hi\", hi)\n  post(\"/home\", home)\n\n# /apiv2/level1/hello\nwith level1:\n  get(\"/hello\", hello)\n  get(\"/hi\", hi)\n  post(\"/home\", home)\n\n# /apiv2/level1/level2/hello\nwith level2:\n  get(\"/hello\", hello)\n  get(\"/hi\", hi)\n  post(\"/home\", home)\n\n# /apiv2/level1/level2/level3/hello\nwith level3:\n  get(\"/hello\", hello)\n  get(\"/hi\", hi)\n  post(\"/home\", home)\n\napp.run()\n</code></pre> <p><code>pattern routing</code> also supports grouping.</p> <pre><code>import prologue\n\n\nvar\n  app = newApp()\n  base = newGroup(app, \"/apiv2\", @[])\n  level1 = newGroup(app,\"/level1\", @[], base)\n  level2 = newGroup(app, \"/level2\", @[], level1)\n\n\nproc hello(ctx: Context) {.async.} =\n  resp \"Hello\"\n\nproc hi(ctx: Context) {.async.} =\n  resp \"Hi\"\n\nproc home(ctx: Context) {.async.} =\n  resp \"Home\"\n\n\nlet\n  urlpattern1 = @[pattern(\"/hello\", hello), pattern(\"/hi\", hi)]\n  urlpattern2 = @[pattern(\"/home\", home)]\n  tab = {level1: urlpattern1, level2: urlpattern2}\n\napp.addGroup(tab)\napp.run()\n</code></pre>"},{"location":"routing/#tips","title":"Tips","text":"<p>You could compile the main program with <code>-d:logueRouteLoose</code> to enable loose route matching. Text and wildcard or text and parameters are considered different. For example <code>/blog/tag/{slug}</code> and <code>/blog/{year}/{id}</code> are not considered as the duplicated routes. If you define <code>/blog/tag/{slug}</code> first, then it will be matched first. Order matters. But <code>/blog/*/{slug}</code> and <code>/blog/{year}/{id}</code> are still duplicated.</p>"},{"location":"server/","title":"Server settings","text":"<p>Current implementation of <code>Prologue</code> supports two HTTP servers. Some settings may work in one of these backends, and won't work in the other backends. This is called additional settings.</p>"},{"location":"server/#settings","title":"Settings","text":"<p>If you want to use <code>maxBody</code> attribute which only work in <code>asynchttpserver</code> backend, you can set them with <code>newSettings</code>. <code>newSettings</code> supports data of JSON format.</p> <p>In <code>asynchttpserver</code> backend(namely <code>-d:usestd</code>), you can set <code>maxBody</code> attribute to respond 413 when the contentLength in HTTP headers is over limitation.</p> <p>In <code>httpx</code> backend, you could set <code>numThreads</code> settings which only work in Unix OS. In windows this setting won't work, the number of threads will always be one. This setting allows user to configure how many threads to run the event loop.</p>"},{"location":"session/","title":"Session","text":"<p>The session helps with storing users' state. If you want to use <code>session</code> or <code>flash</code> messages, you must use <code>sessionMiddleware</code> first.</p>"},{"location":"session/#session-based-on-signed-cookie","title":"Session based on signed cookie","text":"<p>This session is based on signed cookie. It is not safe. You must not use it to store sensitive or important info except for testing.</p> <p>Prologue provides you with <code>sessionMiddleware</code>.</p>"},{"location":"session/#usage","title":"Usage","text":"<p>First you should register <code>sessionMiddleware</code> in global middlewares or handler's middlewares.</p> <pre><code>import prologue\nimport prologue/middlewares/sessions/signedcookiesession\n\nlet settings = newSettings()\nvar app = newApp(settings = settings)\napp.use(sessionMiddleware(settings))\n</code></pre> <p>Then you can use session in all handlers. You can set/get/clear session.</p> <pre><code>proc login*(ctx: Context) {.async.} =\n  ctx.session[\"flywind\"] = \"123\"\n  ctx.session[\"ordontfly\"] = \"345\"\n  resp \"&lt;h1&gt;Hello, Prologue!&lt;/h1&gt;\"\n\nproc logout*(ctx: Context) {.async.} =\n  resp $ctx.session\n</code></pre> <p>More session examples are in Signed Cookie Session and Blog</p>"},{"location":"session/#session-based-on-memory","title":"Session based on memory","text":"<p>The usage of memory session is similar to signed cookie session. Just change the import statement to <code>import prologue/middlewares/sessions/memorysession</code>. This is meant for testing too. Because the data will be lost if the program stops.</p> <pre><code>import prologue\nimport prologue/middlewares/sessions/memorysession\n\n\nlet settings = newSettings()\nvar app = newApp(settings)\napp.use(sessionMiddleware(settings))\n</code></pre>"},{"location":"session/#session-based-on-redis","title":"Session based on redis","text":"<p>You should install <code>redis</code> first(<code>logue extension redis</code>).</p> <pre><code>import prologue\nimport prologue/middlewares/sessions/redissession\n\n\nlet settings = newSettings()\nvar app = newApp(settings)\napp.use(sessionMiddleware(settings))\n</code></pre>"},{"location":"session/#flash-messages","title":"Flash messages","text":"<p>Sometimes you need to store some messages to session, then you can visit these messages in the next request. They will be used once. Once you have visit these messages, they will be popped from the session. You must use one of session middleware above.</p> <pre><code>import src/prologue\nimport src/prologue/middlewares/signedcookiesession\nimport std/with\n\n\nproc hello(ctx: Context) {.async.} =\n  ctx.flash(\"Please retry again!\")\n  resp \"Hello, world\"\n\nproc tea(ctx: Context) {.async.} =\n  let msg = ctx.getFlashedMsg(FlashLevel.Info)\n  if msg.isSome:\n    resp msg.get\n  else:\n    resp \"My tea\"\n\nlet settings = newSettings()\nvar app = newApp(settings)\n\nwith app:\n  use(sessionMiddleware(settings))\n  get(\"/\", hello)\n  get(\"/hello\", hello)\n  get(\"/tea\", tea)\n  run()\n</code></pre>"},{"location":"staticfiles/","title":"Static Files","text":"<p>Prologue supports serving static files.</p>"},{"location":"staticfiles/#send-static-file-response","title":"Send static file Response","text":"<p>You can use <code>staticFileResponse</code> to make a static file response.</p> <pre><code>proc home(ctx: Context) {.async.} =\n  await ctx.staticFileResponse(\"hello.html\", \"\")\n</code></pre>"},{"location":"staticfiles/#download-files","title":"Download files","text":"<p>User maybe want to download some files from the server. You can use <code>staticFileResponse</code> to send the file to be downloaded. </p> <pre><code>proc downloadFile(ctx: Context) {.async.} =\n  await ctx.staticFileResponse(\"index.html\", \"static\", downloadName = \"download.html\")\n</code></pre>"},{"location":"staticfiles/#serve-static-files","title":"Serve static files","text":"<p><code>staticfile</code> is implemented as middleware. It should be imported first. You can specify the path of static directories. <code>staticDirs</code> is of <code>varargs[string]</code> type. It contains all the directories of static files which will be checked in every request.</p> <pre><code>import prologue\nimport prologue/middlewares/staticfile\n\n\nvar app = newApp(settings = settings)\napp.use(staticFileMiddleware(env.get(\"staticDir\")))\n# add your routes\napp.run()\n</code></pre> <p>Multiple directories:</p> <pre><code>import prologue\nimport prologue/middlewares/staticfile\n\n\nvar app = newApp(settings = settings)\napp.use(staticFileMiddleware(\"public\", \"templates\"))\n# Or seq[string]\n# app.use(staticFileMiddleware(@[\"public\", \"templates\"]))\n# Or array[N, string]\n# app.use(staticFileMiddleware([\"public\", \"templates\"]))\napp.addRoute(urls.urlPatterns, \"\")\napp.run()\n</code></pre>"},{"location":"staticfiles/#serving-favicon","title":"Serving Favicon","text":"<p>You may want to add an icon for your website, you can use a favicon. The browser maybe request <code>/favicon.ico</code> to find an icon. <code>redirctTo</code> is handy for this work. <code>dest</code> is the real path of a favicon. For example, you can put it under <code>static</code> directory.</p> <pre><code>import prologue\nfrom prologue/middlewares/staticfile import redirectTo\n\n\nvar app = newApp()\napp.get(\"/favicon.ico\", redirectTo(\"/static/favicon.ico\"))\napp.run()\n</code></pre>"},{"location":"uploadfile/","title":"Upload Files","text":"<p><code>getUploadFile</code> accepts the name of file in order to get the infos. The function returns the name and contents of the file. For this example, the name is \"file\". </p> <pre><code>&lt;form action=\"upload\" method=\"post\" enctype=\"multipart/form-data\"&gt;\n  &lt;input type=\"file\" name=\"file\" value=\"eva\"&gt;\n  &lt;input type=\"submit\" value=\"Submit\" name=\"submit\"&gt;\n&lt;/form&gt;\n</code></pre> <p><code>getUploadFile</code> only works when using form parameters and HttpPost method. <code>Context</code> provides a helper function to <code>save</code> the uploadFile to disks. If you don't specify the name of the file, it will use the origin name from the client.</p> <pre><code>proc upload(ctx: Context) {.async.} =\n  if ctx.request.reqMethod == HttpGet:\n    await ctx.staticFileResponse(\"tests/local/uploadFile/upload.html\", \"\")\n  elif ctx.request.reqMethod == HttpPost:\n    let file = ctx.getUploadFile(\"file\")\n    file.save(\"tests/assets/temp\")\n    file.save(\"tests/assets/temp\", \"set.txt\")\n    resp fmt\"&lt;html&gt;&lt;h1&gt;{file.filename}&lt;/h1&gt;&lt;p&gt;{file.body}&lt;/p&gt;&lt;/html&gt;\"\n</code></pre> <p>The full example</p>"},{"location":"validation/","title":"Validation","text":"<p><code>Prologue</code> provides lots of helper functions for validating data from users.</p>"},{"location":"validation/#single-record","title":"Single Record","text":"<p>Each helper function could be used directly, for examples you want to check whether the content of a string is an int.</p> <pre><code>import prologue/validate/validate\n\nlet\n  msg = \"Int required\"\n  checkInt = isInt(msg)\n\ndoAssert checkInt(\"12\") == (true, \"\")\ndoAssert checkInt(\"912.6) == (false, msg)\n</code></pre>"},{"location":"validation/#multiple-records","title":"Multiple Records","text":"<p>You could also check whether multiple records meets the requirements.</p> <pre><code>import prologue/validate/validate\nimport strtabs\n\nvar form = newFormValidation({\n      \"accepted\": @[required(), accepted()],\n      \"required\": @[required()],\n      \"requiredInt\": @[required(), isInt()],\n      \"minValue\": @[required(), isInt(), minValue(12), maxValue(19)]\n    })\nlet\n  chk1 = form.validate({\"required\": \"on\", \"accepted\": \"true\",\n      \"requiredInt\": \"12\", \"minValue\": \"15\"}.newStringTable)\n  chk2 = form.validate({\"requird\": \"on\", \"time\": \"555\",\n      \"minValue\": \"10\"}.newStringTable)\n  chk3 = form.validate({\"requird\": \"on\", \"time\": \"555\",\n      \"minValue\": \"10\"}.newStringTable, allMsgs = false)\n  chk4 = form.validate({\"required\": \"on\", \"accepted\": \"true\",\n  \"requiredInt\": \"12.5\", \"minValue\": \"13\"}.newStringTable, allMsgs = false)\n\ndoAssert chk1 == (true, \"\")\ndoAssert not chk2.hasValue\ndoAssert chk2.msg == \"Can\\'t find key: accepted\\nCan\\'t find key: \" &amp;\n        \"required\\nCan\\'t find key: requiredInt\\n10 is not greater than or equal to 12.0!\\n\"\ndoAssert not chk3.hasValue\ndoAssert chk3.msg == \"Can\\'t find key: accepted\\n\"\ndoAssert not chk4.hasValue\ndoAssert chk4.msg == \"12.5 is not an integer!\\n\"\n</code></pre>"},{"location":"views/","title":"Views","text":"<p><code>Prologue</code> doesn't provide any templates engines. But we recommend karax to you. <code>karax</code> is a powerful template engines based on DSL. It is suitable for server side rendering.</p> <p>You should use <code>nimble install karax</code> or <code>logue extension karax</code> to install it.</p> <pre><code>import karax / [karaxdsl, vdom]\n\nconst frameworks = [\"Prologue\", \"Httpx\", \"Starlight\"]\n\n\nproc render*(L: openarray[string]): string =\n  let vnode = buildHtml(tdiv(class = \"mt-3\")):\n    h1: text \"Which is my favourite web framework?\"\n    p: text \"echo Prologue\"\n\n    ul:\n      for item in L:\n        li: text item\n    dl:\n      dt: text \"Is Prologue an elegant web framework?\"\n      dd: text \"Yes\"\n  result = $vnode\n\necho render(frameworks)\n</code></pre> <p>You can combine them easily and create reusable components for later use. They are just like plain functions. It is very flexible for you to use them.</p> <pre><code>import karax / [karaxdsl, vdom]\n\nconst frameworks = [\"Prologue\", \"Httpx\", \"Starlight\"]\n\nproc prepare(L: openarray[string]): VNode =\n  result = buildHtml(tdiv):\n    ul:\n      for item in L:\n        li: text item\n    dl:\n      dt: text \"Is Prologue an elegant web framework?\"\n      dd: text \"Yes\"\n\nproc render*(L: openarray[string]): VNode =\n  result = buildHtml(tdiv(class = \"mt-3\")):\n    h1: text \"Which is my favourite web framework?\"\n    p: text \"echo Prologue\"\n    prepare(L)\n\n\necho $render(frameworks)\n</code></pre>"},{"location":"websocket/","title":"Websocket","text":"<p><code>Prologue</code> provides <code>websocket</code> supports, you need to install <code>websocketx</code> first(<code>nimble install websocketx</code> or <code>logue extension websocketx</code>).</p>"},{"location":"websocket/#echo-server-example","title":"Echo server example","text":"<p>First create a new websocket object, then you can send msgs to the client. Finally, you receive msgs from the client and send them back to the client.</p> <pre><code>import prologue\nimport prologue/websocket\n\n\nproc hello*(ctx: Context) {.async.} =\n  var ws = await newWebSocket(ctx)\n  await ws.send(\"Welcome to simple echo server\")\n  while ws.readyState == Open:\n    let packet = await ws.receiveStrPacket()\n    await ws.send(packet)\n\n  resp \"&lt;h1&gt;Hello, Prologue!&lt;/h1&gt;\"\n</code></pre>"},{"location":"websocket/#more-details","title":"More details","text":"<p>You can ref to ws to find more usages.</p>"}]}